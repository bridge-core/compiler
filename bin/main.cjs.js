#!/usr/bin/env node
"use strict";var e=require("yargs"),t=require("fs"),i=require("path");function r(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}async function n(e,r,a){let o=await t.promises.readdir(e,{withFileTypes:!0});return await Promise.all(o.map((async t=>{t.isFile()?await a(i.join(e,t.name),i.join(r,t.name)):await n(i.join(e,t.name),i.join(r,t.name),a)}))),[]}function a(e,t,i,r){i.add(e);for(let n of e.dependencies){if("string"==typeof n){const e=r.get(n);if(!e)throw new Error(`Undefined lookup in key registry: "${n}"`);n=e}if(!t.has(n)){if(i.has(n))throw new Error("Circular dependency detected!");a(n,t,i,r)}}t.add(e),i.delete(e)}function o(e,t){let i=new Set;return e.forEach((e=>{i.has(e)||a(e,i,new Set,t)})),i}function s(e,t){var i;return null!==(i=t.find((t=>!t.match||function(e,t){return"string"==typeof e?e.startsWith("RP/")||e.startsWith("BP/")?t.matchPath.startsWith(e):t.relPath.startsWith(e):e(t)}(t.match,e))))&&void 0!==i?i:{}}async function c(e,i,r,n,a,o=!1){const c=function(e,t,i=!1){let r,n=new Set;return{get isRpFile(){return i},get absPath(){return e},get relPath(){return t},get matchPath(){return`${i?"RP/":"BP/"}${t.replace(/\\/g,"/")}`},get dependencies(){return n},get fileContent(){return r},set fileContent(e){r=e},add(e){n.add(e)},remove(e){n.delete(e)}}}(e,i,o);c.fileContent=await t.promises.readFile(c.absPath),r.set(e,c);const l=function(e,t){var i;return null!==(i=s(e,t).plugins)&&void 0!==i?i:[]}(c,a);await Promise.all(l.map((async e=>{var t;const i=await(null===(t=e.afterRead)||void 0===t?void 0:t.call(e,c));i&&(c.fileContent=i)}))),await Promise.all(l.map((e=>{var t;return null===(t=e.resolveDependencies)||void 0===t?void 0:t.call(e,c,n)})))}!async function({bp:e,obp:r,rp:a,orp:l,resolve:d}){var p,u,f;await Promise.all([t.promises.mkdir(r,{recursive:!0}),t.promises.mkdir(l,{recursive:!0})]).catch((()=>{}));const h=new Map,m=new Map;await n(e,".",((e,t)=>c(e,t,h,m,d))),await n(a,".",((e,t)=>c(e,t,h,m,d,!0)));const v=[...o(h,m)];console.log(v.map((e=>e.matchPath)));for(const e of v){const n=s(e,d),a=null!==(p=n.plugins)&&void 0!==p?p:[];if(0!==a.length||n.doNotTransfer){for(const t of a){const i=await(null===(u=t.transform)||void 0===u?void 0:u.call(t,e));i&&(e.fileContent=i)}for(const t of a.reverse()){const i=await(null===(f=t.afterTransform)||void 0===f?void 0:f.call(t,e));i&&(e.fileContent=i)}if(!n.doNotTransfer){const n=i.join(e.isRpFile?l:r,e.relPath);try{await t.promises.mkdir(i.dirname(n),{recursive:!0})}catch(e){}await t.promises.writeFile(n,e.fileContent)}}else{const n=i.join(e.isRpFile?l:r,e.relPath);try{await t.promises.mkdir(i.dirname(n),{recursive:!0})}catch(e){}await t.promises.copyFile(e.absPath,n)}}}(r(e).default.config("config","Run bridge-compiler with the given config",(e=>require(e))).usage("Usage: bridge-compiler --config <path>").option("bp",{describe:"Path to your behavior pack",type:"string",demandOption:!0}).option("obp",{alias:"outputbp",describe:"Where to save the compiled behavior pack",type:"string",demandOption:!0}).option("rp",{describe:"Path to your resource pack",type:"string",demandOption:!0}).option("orp",{alias:"outputrp",describe:"Where to save the compiled resource pack",type:"string",demandOption:!0}).argv);
