#!/usr/bin/env node
"use strict";function e(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var a=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,a.get?a:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}let t,r;async function a(e,r,i){let n=await t.readdir(e,{withFileTypes:!0});return await Promise.all(n.map((async n=>{n.isFile()?await i(t.join(e,n.name),t.join(r,n.name)):await a(t.join(e,n.name),t.join(r,n.name),i)}))),[]}function i(e,t,r,a){r.add(e);for(let n of e.dependencies){if("string"==typeof n){const e=a.get(n);if(!e)throw new Error(`Undefined lookup in key registry: "${n}"`);n=e}if(!t.has(n)){if(r.has(n))throw new Error("Circular dependency detected!");i(n,t,r,a)}}t.add(e),r.delete(e)}function n(e,t){let r=new Set;return e.forEach((e=>{r.has(e)||i(e,r,new Set,t)})),r}function o(e,t){var r;return null!==(r=t.find((t=>!t.match||function(e,t){return"string"==typeof e?e.startsWith("RP/")||e.startsWith("BP/")?t.matchPath.startsWith(e):t.relPath.startsWith(e):e(t)}(t.match,e))))&&void 0!==r?r:{}}async function s(e,r,a,i,n,s=!1,c,l){const d=function(e,r,a=!1){let i,n,o=new Set;return{get isRpFile(){return a},get absPath(){return e},get relPath(){return r},get matchPath(){return t.join(a?"RP":"BP",r.replace(/\\/g,"/"))},get dependencies(){return o},get fileContent(){return i},set fileContent(e){i=e},get savePath(){return n},set savePath(e){n=e},add(e){o.add(e)},remove(e){o.delete(e)}}}(e,r,s);d.fileContent=await t.readFile(d.absPath),d.savePath=t.join(d.isRpFile?l:c,d.relPath),a.set(e,d);const u=function(e,t){var r;return null!==(r=o(e,t).plugins)&&void 0!==r?r:[]}(d,n);await Promise.all(u.map((async e=>{var t;const r=await(null===(t=e.afterRead)||void 0===t?void 0:t.call(e,d));r&&(d.fileContent=r)}))),await Promise.all(u.map((e=>{var t;return null===(t=e.resolveDependencies)||void 0===t?void 0:t.call(e,d,i)})))}async function c({bp:e,obp:r,rp:i,orp:c,resolve:l},d){var u,f,p;!function(e){t=e}(d),await Promise.all([t.rmdir(r,{recursive:!0}),t.rmdir(c,{recursive:!0})]),await Promise.all([t.mkdir(r,{recursive:!0}),t.mkdir(c,{recursive:!0})]).catch((()=>{}));const h=new Map,v=new Map;await a(e,".",((e,t)=>s(e,t,h,v,l,!1,r,c))),await a(i,".",((e,t)=>s(e,t,h,v,l,!0,r,c)));const m=[...n(h,v)];for(const e of m){const r=o(e,l),a=null!==(u=r.plugins)&&void 0!==u?u:[];if(0!==a.length||r.doNotTransfer){for(const t of a){const r=await(null===(f=t.transform)||void 0===f?void 0:f.call(t,e));r&&(e.fileContent=r)}for(const t of a.reverse()){const r=await(null===(p=t.afterTransform)||void 0===p?void 0:p.call(t,e));r&&(e.fileContent=r)}if(!r.doNotTransfer){try{await t.mkdir(t.dirname(e.savePath),{recursive:!0})}catch{}await t.writeFile(e.savePath,e.fileContent)}}else{try{await t.mkdir(t.dirname(e.savePath),{recursive:!0})}catch{}await t.copyFile(e.absPath,e.savePath)}}}Object.defineProperty(exports,"__esModule",{value:!0}),(async()=>{const t=await Promise.resolve().then((function(){return e(require("yargs"))}));r=t.config("config","Run bridge-compiler with the given config",(e=>require(e))).usage("Usage: bridge-compiler --config <path>").option("bp",{describe:"Path to your behavior pack",type:"string",demandOption:!0}).option("obp",{alias:"outputbp",describe:"Where to save the compiled behavior pack",type:"string",demandOption:!0}).option("rp",{describe:"Path to your resource pack",type:"string",demandOption:!0}).option("orp",{alias:"outputrp",describe:"Where to save the compiled resource pack",type:"string",demandOption:!0}).argv,c(r,{...require("fs"),...require("path")})})(),exports.buildAddOn=c;
