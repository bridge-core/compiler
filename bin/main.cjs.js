#!/usr/bin/env node
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("fs"),t=require("path");function r(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var i=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,i.get?i:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}async function i(r,a,n){let o=await e.promises.readdir(r,{withFileTypes:!0});return await Promise.all(o.map((async e=>{e.isFile()?await n(t.join(r,e.name),t.join(a,e.name)):await i(t.join(r,e.name),t.join(a,e.name),n)}))),[]}function a(e,t,r,i){r.add(e);for(let n of e.dependencies){if("string"==typeof n){const e=i.get(n);if(!e)throw new Error(`Undefined lookup in key registry: "${n}"`);n=e}if(!t.has(n)){if(r.has(n))throw new Error("Circular dependency detected!");a(n,t,r,i)}}t.add(e),r.delete(e)}function n(e,t){let r=new Set;return e.forEach((e=>{r.has(e)||a(e,r,new Set,t)})),r}function o(e,t){var r;return null!==(r=t.find((t=>!t.match||function(e,t){return"string"==typeof e?e.startsWith("RP/")||e.startsWith("BP/")?t.matchPath.startsWith(e):t.relPath.startsWith(e):e(t)}(t.match,e))))&&void 0!==r?r:{}}async function s(r,i,a,n,s,c=!1,l,d){const u=function(e,t,r=!1){let i,a,n=new Set;return{get isRpFile(){return r},get absPath(){return e},get relPath(){return t},get matchPath(){return`${r?"RP/":"BP/"}${t.replace(/\\/g,"/")}`},get dependencies(){return n},get fileContent(){return i},set fileContent(e){i=e},get savePath(){return a},set savePath(e){a=e},add(e){n.add(e)},remove(e){n.delete(e)}}}(r,i,c);u.fileContent=await e.promises.readFile(u.absPath),u.savePath=t.join(u.isRpFile?d:l,u.relPath),a.set(r,u);const p=function(e,t){var r;return null!==(r=o(e,t).plugins)&&void 0!==r?r:[]}(u,s);await Promise.all(p.map((async e=>{var t;const r=await(null===(t=e.afterRead)||void 0===t?void 0:t.call(e,u));r&&(u.fileContent=r)}))),await Promise.all(p.map((e=>{var t;return null===(t=e.resolveDependencies)||void 0===t?void 0:t.call(e,u,n)})))}async function c({bp:r,obp:a,rp:c,orp:l,resolve:d}){var u,p,f;await Promise.all([e.promises.mkdir(a,{recursive:!0}),e.promises.mkdir(l,{recursive:!0})]).catch((()=>{}));const h=new Map,m=new Map;await i(r,".",((e,t)=>s(e,t,h,m,d,!1,a,l))),await i(c,".",((e,t)=>s(e,t,h,m,d,!0,a,l)));const v=[...n(h,m)];for(const r of v){const i=o(r,d),a=null!==(u=i.plugins)&&void 0!==u?u:[];if(0!==a.length||i.doNotTransfer){for(const e of a){const t=await(null===(p=e.transform)||void 0===p?void 0:p.call(e,r));t&&(r.fileContent=t)}for(const e of a.reverse()){const t=await(null===(f=e.afterTransform)||void 0===f?void 0:f.call(e,r));t&&(r.fileContent=t)}if(!i.doNotTransfer){try{await e.promises.mkdir(t.dirname(r.savePath),{recursive:!0})}catch(e){}await e.promises.writeFile(r.savePath,r.fileContent)}}else{try{await e.promises.mkdir(t.dirname(r.savePath),{recursive:!0})}catch(e){}await e.promises.copyFile(r.absPath,r.savePath)}}}let l;(async()=>{const e=await Promise.resolve().then((function(){return r(require("yargs"))}));l=e.config("config","Run bridge-compiler with the given config",(e=>require(e))).usage("Usage: bridge-compiler --config <path>").option("bp",{describe:"Path to your behavior pack",type:"string",demandOption:!0}).option("obp",{alias:"outputbp",describe:"Where to save the compiled behavior pack",type:"string",demandOption:!0}).option("rp",{describe:"Path to your resource pack",type:"string",demandOption:!0}).option("orp",{alias:"outputrp",describe:"Where to save the compiled resource pack",type:"string",demandOption:!0}).argv,c(l)})(),exports.buildAddOn=c;
