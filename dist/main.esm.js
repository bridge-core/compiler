import{promises as t}from"fs";import{join as e,dirname as a}from"path";async function n(a,r,i){let o=await t.readdir(a,{withFileTypes:!0});return await Promise.all(o.map((async t=>{t.isFile()?await i(e(a,t.name),e(r,t.name)):await n(e(a,t.name),e(r,t.name),i)}))),[]}function r(t,e,a,n){a.add(t);for(let i of t.dependencies){if("string"==typeof i){const t=n.get(i);if(!t)throw new Error(`Undefined lookup in key registry: "${i}"`);i=t}if(!e.has(i)){if(a.has(i))throw new Error("Circular dependency detected!");r(i,e,a,n)}}e.add(t),a.delete(t)}function i(t,e){let a=new Set;return t.forEach((t=>{a.has(t)||r(t,a,new Set,e)})),a}function o(t,e){var a;return null!==(a=e.find((e=>!e.match||function(t,e){return"string"==typeof t?t.startsWith("RP/")||t.startsWith("BP/")?e.matchPath.startsWith(t):e.relPath.startsWith(t):t(e)}(e.match,t))))&&void 0!==a?a:{}}async function l(e,a,n,r,i,l=!1){const s=function(t,e,a=!1){let n,r=new Set;return{get isRpFile(){return a},get absPath(){return t},get relPath(){return e},get matchPath(){return`${a?"RP/":"BP/"}${e.replace(/\\/g,"/")}`},get dependencies(){return r},get fileContent(){return n},set fileContent(t){n=t},add(t){r.add(t)},remove(t){r.delete(t)}}}(e,a,l);s.fileContent=await t.readFile(s.absPath),n.set(e,s);const c=function(t,e){var a;return null!==(a=o(t,e).plugins)&&void 0!==a?a:[]}(s,i);await Promise.all(c.map((async t=>{var e;const a=await(null===(e=t.afterRead)||void 0===e?void 0:e.call(t,s));a&&(s.fileContent=a)}))),await Promise.all(c.map((t=>{var e;return null===(e=t.resolveDependencies)||void 0===e?void 0:e.call(t,s,r)})))}async function s({bp:r,obp:s,rp:c,orp:f,resolve:d}){var u,h,p;await Promise.all([t.mkdir(s,{recursive:!0}),t.mkdir(f,{recursive:!0})]).catch((()=>{}));const m=new Map,w=new Map;await n(r,".",((t,e)=>l(t,e,m,w,d))),await n(c,".",((t,e)=>l(t,e,m,w,d,!0)));const v=[...i(m,w)];console.log(v.map((t=>t.matchPath)));for(const n of v){const r=o(n,d),i=null!==(u=r.plugins)&&void 0!==u?u:[];if(0!==i.length||r.doNotTransfer){for(const t of i){const e=await(null===(h=t.transform)||void 0===h?void 0:h.call(t,n));e&&(n.fileContent=e)}for(const t of i.reverse()){const e=await(null===(p=t.afterTransform)||void 0===p?void 0:p.call(t,n));e&&(n.fileContent=e)}if(!r.doNotTransfer){const r=e(n.isRpFile?f:s,n.relPath);try{await t.mkdir(a(r),{recursive:!0})}catch(t){}await t.writeFile(r,n.fileContent)}}else{const r=e(n.isRpFile?f:s,n.relPath);try{await t.mkdir(a(r),{recursive:!0})}catch(t){}await t.copyFile(n.absPath,r)}}}export{s as buildAddOn};
