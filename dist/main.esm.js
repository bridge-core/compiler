import{promises as t}from"fs";import{join as e,dirname as a}from"path";async function r(a,n,i){let o=await t.readdir(a,{withFileTypes:!0});return await Promise.all(o.map((async t=>{t.isFile()?await i(e(a,t.name),e(n,t.name)):await r(e(a,t.name),e(n,t.name),i)}))),[]}function n(t,e,a,r){a.add(t);for(let i of t.dependencies){if("string"==typeof i){const t=r.get(i);if(!t)throw new Error(`Undefined lookup in key registry: "${i}"`);i=t}if(!e.has(i)){if(a.has(i))throw new Error("Circular dependency detected!");n(i,e,a,r)}}e.add(t),a.delete(t)}function i(t,e){let a=new Set;return t.forEach((t=>{a.has(t)||n(t,a,new Set,e)})),a}function o(t,e){var a;return null!==(a=e.find((e=>!e.match||function(t,e){return"string"==typeof t?t.startsWith("RP/")||t.startsWith("BP/")?e.matchPath.startsWith(t):e.relPath.startsWith(t):t(e)}(e.match,t))))&&void 0!==a?a:{}}async function s(a,r,n,i,s,l=!1,c,f){const d=function(t,e,a=!1){let r,n,i=new Set;return{get isRpFile(){return a},get absPath(){return t},get relPath(){return e},get matchPath(){return`${a?"RP/":"BP/"}${e.replace(/\\/g,"/")}`},get dependencies(){return i},get fileContent(){return r},set fileContent(t){r=t},get savePath(){return n},set savePath(t){n=t},add(t){i.add(t)},remove(t){i.delete(t)}}}(a,r,l);d.fileContent=await t.readFile(d.absPath),d.savePath=e(d.isRpFile?f:c,d.relPath),n.set(a,d);const u=function(t,e){var a;return null!==(a=o(t,e).plugins)&&void 0!==a?a:[]}(d,s);await Promise.all(u.map((async t=>{var e;const a=await(null===(e=t.afterRead)||void 0===e?void 0:e.call(t,d));a&&(d.fileContent=a)}))),await Promise.all(u.map((t=>{var e;return null===(e=t.resolveDependencies)||void 0===e?void 0:e.call(t,d,i)})))}async function l({bp:e,obp:n,rp:l,orp:c,resolve:f}){var d,u,h;await Promise.all([t.mkdir(n,{recursive:!0}),t.mkdir(c,{recursive:!0})]).catch((()=>{}));const v=new Map,w=new Map;await r(e,".",((t,e)=>s(t,e,v,w,f,!1,n,c))),await r(l,".",((t,e)=>s(t,e,v,w,f,!0,n,c)));const p=[...i(v,w)];for(const e of p){const r=o(e,f),n=null!==(d=r.plugins)&&void 0!==d?d:[];if(0!==n.length||r.doNotTransfer){for(const t of n){const a=await(null===(u=t.transform)||void 0===u?void 0:u.call(t,e));a&&(e.fileContent=a)}for(const t of n.reverse()){const a=await(null===(h=t.afterTransform)||void 0===h?void 0:h.call(t,e));a&&(e.fileContent=a)}if(!r.doNotTransfer){try{await t.mkdir(a(e.savePath),{recursive:!0})}catch(t){}await t.writeFile(e.savePath,e.fileContent)}}else{try{await t.mkdir(a(e.savePath),{recursive:!0})}catch(t){}await t.copyFile(e.absPath,e.savePath)}}}export{l as buildAddOn};
