let e;async function t(a,n,r){let i=await e.readdir(a,{withFileTypes:!0});return await Promise.all(i.map((async i=>{i.isFile()?await r(e.join(a,i.name),e.join(n,i.name)):await t(e.join(a,i.name),e.join(n,i.name),r)}))),[]}function a(e,t,n,r){n.add(e);for(let i of e.dependencies){if("string"==typeof i){const e=r.get(i);if(!e)throw new Error(`Undefined lookup in key registry: "${i}"`);i=e}if(!t.has(i)){if(n.has(i))throw new Error("Circular dependency detected!");a(i,t,n,r)}}t.add(e),n.delete(e)}function n(e,t){let n=new Set;return e.forEach((e=>{n.has(e)||a(e,n,new Set,t)})),n}function r(e,t){var a;return null!==(a=t.find((t=>!t.match||function(e,t){return"string"==typeof e?e.startsWith("RP/")||e.startsWith("BP/")?t.matchPath.startsWith(e):t.relPath.startsWith(e):e(t)}(t.match,e))))&&void 0!==a?a:{}}async function i(t,a,n,i,o,s=!1,l,c){const d=function(t,a,n=!1){let r,i,o=new Set;return{get isRpFile(){return n},get absPath(){return t},get relPath(){return a},get matchPath(){return e.join(n?"RP":"BP",a.replace(/\\/g,"/"))},get dependencies(){return o},get fileContent(){return r},set fileContent(e){r=e},get savePath(){return i},set savePath(e){i=e},add(e){o.add(e)},remove(e){o.delete(e)}}}(t,a,s);d.fileContent=await e.readFile(d.absPath),d.savePath=e.join(d.isRpFile?c:l,d.relPath),n.set(t,d);const f=function(e,t){var a;return null!==(a=r(e,t).plugins)&&void 0!==a?a:[]}(d,o);await Promise.all(f.map((async e=>{var t;const a=await(null===(t=e.afterRead)||void 0===t?void 0:t.call(e,d));a&&(d.fileContent=a)}))),await Promise.all(f.map((e=>{var t;return null===(t=e.resolveDependencies)||void 0===t?void 0:t.call(e,d,i)})))}async function o({bp:a,obp:o,rp:s,orp:l,resolve:c},d){var f,u,h;!function(t){e=t}(d),await Promise.all([e.rmdir(o,{recursive:!0}),e.rmdir(l,{recursive:!0})]),await Promise.all([e.mkdir(o,{recursive:!0}),e.mkdir(l,{recursive:!0})]).catch((()=>{}));const v=new Map,w=new Map;await t(a,".",((e,t)=>i(e,t,v,w,c,!1,o,l))),await t(s,".",((e,t)=>i(e,t,v,w,c,!0,o,l)));const m=[...n(v,w)];for(const t of m){const a=r(t,c),n=null!==(f=a.plugins)&&void 0!==f?f:[];if(0!==n.length||a.doNotTransfer){for(const e of n){const a=await(null===(u=e.transform)||void 0===u?void 0:u.call(e,t));a&&(t.fileContent=a)}for(const e of n.reverse()){const a=await(null===(h=e.afterTransform)||void 0===h?void 0:h.call(e,t));a&&(t.fileContent=a)}if(!a.doNotTransfer){try{await e.mkdir(e.dirname(t.savePath),{recursive:!0})}catch{}await e.writeFile(t.savePath,t.fileContent)}}else{try{await e.mkdir(e.dirname(t.savePath),{recursive:!0})}catch{}await e.copyFile(t.absPath,t.savePath)}}}export{o as buildAddOn};
