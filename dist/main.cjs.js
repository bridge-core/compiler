"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("fs"),t=require("path");async function r(i,n,a){let o=await e.promises.readdir(i,{withFileTypes:!0});return await Promise.all(o.map((async e=>{e.isFile()?await a(t.join(i,e.name),t.join(n,e.name)):await r(t.join(i,e.name),t.join(n,e.name),a)}))),[]}function i(e,t,r,n){r.add(e);for(let a of e.dependencies){if("string"==typeof a){const e=n.get(a);if(!e)throw new Error(`Undefined lookup in key registry: "${a}"`);a=e}if(!t.has(a)){if(r.has(a))throw new Error("Circular dependency detected!");i(a,t,r,n)}}t.add(e),r.delete(e)}function n(e,t){let r=new Set;return e.forEach((e=>{r.has(e)||i(e,r,new Set,t)})),r}function a(e,t){var r;return null!==(r=t.find((t=>!t.match||function(e,t){return"string"==typeof e?e.startsWith("RP/")||e.startsWith("BP/")?t.matchPath.startsWith(e):t.relPath.startsWith(e):e(t)}(t.match,e))))&&void 0!==r?r:{}}async function o(t,r,i,n,o,s=!1){const l=function(e,t,r=!1){let i,n=new Set;return{get isRpFile(){return r},get absPath(){return e},get relPath(){return t},get matchPath(){return`${r?"RP/":"BP/"}${t.replace(/\\/g,"/")}`},get dependencies(){return n},get fileContent(){return i},set fileContent(e){i=e},add(e){n.add(e)},remove(e){n.delete(e)}}}(t,r,s);l.fileContent=await e.promises.readFile(l.absPath),i.set(t,l);const c=function(e,t){var r;return null!==(r=a(e,t).plugins)&&void 0!==r?r:[]}(l,o);await Promise.all(c.map((async e=>{var t;const r=await(null===(t=e.afterRead)||void 0===t?void 0:t.call(e,l));r&&(l.fileContent=r)}))),await Promise.all(c.map((e=>{var t;return null===(t=e.resolveDependencies)||void 0===t?void 0:t.call(e,l,n)})))}async function s({bp:i,obp:s,rp:l,orp:c,resolve:d}){var f,u,p;await Promise.all([e.promises.mkdir(s,{recursive:!0}),e.promises.mkdir(c,{recursive:!0})]).catch((()=>{}));const m=new Map,h=new Map;await r(i,".",((e,t)=>o(e,t,m,h,d))),await r(l,".",((e,t)=>o(e,t,m,h,d,!0)));const w=[...n(m,h)];console.log(w.map((e=>e.matchPath)));for(const r of w){const i=a(r,d),n=null!==(f=i.plugins)&&void 0!==f?f:[];if(0!==n.length||i.doNotTransfer){for(const e of n){const t=await(null===(u=e.transform)||void 0===u?void 0:u.call(e,r));t&&(r.fileContent=t)}for(const e of n.reverse()){const t=await(null===(p=e.afterTransform)||void 0===p?void 0:p.call(e,r));t&&(r.fileContent=t)}if(!i.doNotTransfer){const i=t.join(r.isRpFile?c:s,r.relPath);try{await e.promises.mkdir(t.dirname(i),{recursive:!0})}catch(e){}await e.promises.writeFile(i,r.fileContent)}}else{const i=t.join(r.isRpFile?c:s,r.relPath);try{await e.promises.mkdir(t.dirname(i),{recursive:!0})}catch(e){}await e.promises.copyFile(r.absPath,i)}}}exports.buildAddOn=s;
