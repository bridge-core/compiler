"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("fs"),t=require("path");async function a(r,i,n){let s=await e.promises.readdir(r,{withFileTypes:!0});return await Promise.all(s.map((async e=>{e.isFile()?await n(t.join(r,e.name),t.join(i,e.name)):await a(t.join(r,e.name),t.join(i,e.name),n)}))),[]}function r(e,t,a,i){a.add(e);for(let n of e.dependencies){if("string"==typeof n){const e=i.get(n);if(!e)throw new Error(`Undefined lookup in key registry: "${n}"`);n=e}if(!t.has(n)){if(a.has(n))throw new Error("Circular dependency detected!");r(n,t,a,i)}}t.add(e),a.delete(e)}function i(e,t){let a=new Set;return e.forEach((e=>{a.has(e)||r(e,a,new Set,t)})),a}function n(e,t){var a;return null!==(a=t.find((t=>!t.match||function(e,t){return"string"==typeof e?e.startsWith("RP/")||e.startsWith("BP/")?t.matchPath.startsWith(e):t.relPath.startsWith(e):e(t)}(t.match,e))))&&void 0!==a?a:{}}async function s(a,r,i,s,o,l=!1,c,d){const u=function(e,t,a=!1){let r,i,n=new Set;return{get isRpFile(){return a},get absPath(){return e},get relPath(){return t},get matchPath(){return`${a?"RP/":"BP/"}${t.replace(/\\/g,"/")}`},get dependencies(){return n},get fileContent(){return r},set fileContent(e){r=e},get savePath(){return i},set savePath(e){i=e},add(e){n.add(e)},remove(e){n.delete(e)}}}(a,r,l);u.fileContent=await e.promises.readFile(u.absPath),u.savePath=t.join(u.isRpFile?d:c,u.relPath),i.set(a,u);const f=function(e,t){var a;return null!==(a=n(e,t).plugins)&&void 0!==a?a:[]}(u,o);await Promise.all(f.map((async e=>{var t;const a=await(null===(t=e.afterRead)||void 0===t?void 0:t.call(e,u));a&&(u.fileContent=a)}))),await Promise.all(f.map((e=>{var t;return null===(t=e.resolveDependencies)||void 0===t?void 0:t.call(e,u,s)})))}async function o({bp:r,obp:o,rp:l,orp:c,resolve:d}){var u,f,h;await Promise.all([e.promises.mkdir(o,{recursive:!0}),e.promises.mkdir(c,{recursive:!0})]).catch((()=>{}));const p=new Map,v=new Map;await a(r,".",((e,t)=>s(e,t,p,v,d,!1,o,c))),await a(l,".",((e,t)=>s(e,t,p,v,d,!0,o,c)));const m=[...i(p,v)];for(const a of m){const r=n(a,d),i=null!==(u=r.plugins)&&void 0!==u?u:[];if(0!==i.length||r.doNotTransfer){for(const e of i){const t=await(null===(f=e.transform)||void 0===f?void 0:f.call(e,a));t&&(a.fileContent=t)}for(const e of i.reverse()){const t=await(null===(h=e.afterTransform)||void 0===h?void 0:h.call(e,a));t&&(a.fileContent=t)}if(!r.doNotTransfer){try{await e.promises.mkdir(t.dirname(a.savePath),{recursive:!0})}catch(e){}await e.promises.writeFile(a.savePath,a.fileContent)}}else{try{await e.promises.mkdir(t.dirname(a.savePath),{recursive:!0})}catch(e){}await e.promises.copyFile(a.absPath,a.savePath)}}}exports.buildAddOn=o;
